# 컴포넌트 스캔과 의존관계 자동 주입 시작하기

- 지금까지 스프링 빈을 등록할 때 **Annotation 방식**을 사용했거나 **XML의 <bean>**을 사용해 설정 정보애 직접 등록할 스프링 빈을 나열했다.
- 스프링 빈이 적게는 수십개, 많게는 수백개 된다면 이 작업**이 엄청 귀찮고, 실수를 유발하는 문제가 된다.**
- 이런 문제 때문에 스프링은 **설정 정보가 없더라도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공.**
- 또 의존관계도 자동으로 주입하는 **@Autowired라는 기능을 제공.**

### 컴포넌트 스캔은 이름 그대로 @Component 어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.

> 참고
**@Configuration이 컴포넌트 스캔이 대상이 된 이유**도 @Configuration 소스코드를 열어보면 **@Conponent 애너테이션이 붙어** 있기 때문
>

## @Autowired

- 의존관계를 자동으로 주입해준다.
- 여러 의존관계도 한번에 주입 받을 수 있다.

## 컴포넌트 스캔과 자동 의존관계 주입 동작 방식

1. @ComponentScan
    1. @ComponentScan은 @Component가 붙은 모든 클래스를 스프링 빈으로 등록.
    2. 스프링 빈의 기본 이름은 클래스 명의 맨 앞글자를 소문자로 바꿔, 사용. 만약 지정하고 싶으면 @Component(”원하는 이름”)을 쓰면 됨.
2. @Autowired 의존관계 자동 주입
    1. 생성자에 @Autowired를 지정 ⇒ 스프링 컨테이너가 자동으로 찾아서 주입.
    2. 이 때 기본 조회 전약은 타입이 같은 빈을 찾아서 주입.
        1. getBean(MemberRepository.class)와 동일하다고 이해하면 됨.
    3. 파라미터가 많아도 알아서 잘 찾아줌.


# 의존관계 주입 방식

### 의미

- 외부에서 **두 객체 간의 관계를 결정해주는 디자인 패턴**, 인터페이스를 사이에 둬, **클래스 레벨에서는 의존관계가 고정되지 않도록**하고 **런타임 시에 관계를 동적으로 주입**

### 방식

- 필드 주입

```java
@Autowired private A a;
```

- 새터 주입

```java
@Autowired
public void setA(B newA){
	this.a = newA;
}
```

- 생성자 주입

```java
@Autowired
public A(B a){
	this.a = a
}
```

### 이유

- 두 클래스가 **강하게 결합**되어 있고, 객체들 간의 관계가 아니라 객체들 간의 관계가 아니라 **클래스 간의 관계가 맺어짐.**
- 두 객체 간의 관계라는 관심사의 분리
- 유연성을 높이기 위해
- 테스트 작성을 용이하게 함.

### 결론

의존 관계를 주입할 객체를 계속해서 생성하고 소멸한다면, 아무리 GC가 성능이 좋아졌다고 하더라도 부담이 된다. 그래서 **Spring에서는 싱글톤**을 사용해서 관리함.

# 탐색 위치와 기본 스캔 대상

### 탐색할 패키지의 시작 위치 지정

모든 자바 클래스를 다 컴포넌트 스캔하면 시간이 오래 걸린다. 그래서 꼭 필요한 위치부터 탐색하도록 설정할 수 있다.

```java
@ComponentScan(
		basePackages = "hello.core"
)
```

- basePackages: 탐색할 패키지의 시작 위치를 지정한다. 이 패키지를 포함해서 하위 패키지를 모두 탐색한다.
    - basePasckages = {”hello.core”, “hello.service”} 이렇게 여러 시작 위치를 지정할 수도 있다.
- basePackageClasses: 지정한 클래스의 패키지를 탐색 시작 위치로 지정한다.
- 만약 지정하지 않으면 @ComponentScan이 붙은 설정 정보 클래스의 패키지가 시작 위치가 됨.

### 권장하는 방법

그냥 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것이다. 최근 스프링 부트도 이 방법을 기본으로 제공.

### 컴포넌트 스캔 기본 대상

컴포넌트 스캔은 @Component뿐만 아니라 여러 대상도 푸함된다

- @Component: 컴포넌트 스캔에 사용
- @Controller: 스프링 MVC 컨트롤러에서 사용
- @Service: 스프링 비즈니스 로직에서 사용
- @Repository: 스프링 데이터 접근 계층에서 사용
- @Configuration: 스프링 설정 정보에서 사용

위 클래스의 소스코드를 보면 @Component를 포함하고 있음.

> **참고**
애노테이션에는 상속관계가 없다. 그래서 애노테이션이 특정 애노테이션을 들고 있는 것을 인식할 수 있는 것은 자바 기능이 아니라, 스프링이 지원하는 기능이다.
>

1 컴포넌트 스캔의 용도 뿐만 아니라 다음 애노테이션이 있으면 스프링은 부가 기능을 수행한다.

- @Controller : 스프링 MVC 컨트롤러로 인식
- @Repository : 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.
- @Configuration : 앞서 보았듯이 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다.
- @Service : 사실 @Service 는 특별한 처리를 하지 않는다. 대신 개발자들이 핵심 비즈니스 로직이 여기에 있겠구나 라고 비즈니스 계층을 인식하는데 도움이 된다.

> 참고
useDefaultFilters 옵션은 기본으로 켜져있는데, 이 옵션을 끄면 기본 스캔 대상들이 제외된다.
그냥 이런 옵션이 있구나 정도 알고 넘어가자.
>

# 필터

- includeFilters : 컴포넌트 스캔 대상을 추가로 지정.
- excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정한다.

## FilterType의 5가지 옵션

- ANNOTATION : 기본 값, 애노테이션을 인식해서 동작한다.
    - ex) org.example.SomeAnnotation
- ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다.
    - ex) org.example.SomeClass
- ASPECTJ: AspectJ 패턴 사용
    - ex) org.example..*Service+
- REGEX: 정규 표현식
    - ex) org\.example\.Default.*
- CUSTOM: TypeFilter 이라는 인터페이스를 구현해서 처리
    - ex) org.example.MyTypeFilter

> 참고
**`@Component`면 충분**하기 때문에, `includeFilters`를 **사용할 일은 거의 없다**.
`excludeFilters`는 여러가지 이유로 간혹 사용할 때가 있지만, 많이는 아니다.
요즘 스프링 부트는 컴포넌트 스캔을 기본으로 제공하는데, **개인적으로 옵션을 변경하면서 사용하기 보다는 스프링 기본 설정에 최대한 맞춰 사용하는 것을 권장, 선호하는 편.**
>

# 자동 등록과 충돌

컴포넌트 스캔에서 같은 빈 이름을 등록하면 어떻게 될까?

1. 자동 빈 등록 vs 자동 빈 등록
2. 수동 빈 등록 vs 자동 빈 등록

### 자동 빈 등록 vs 자동 빈 등록

컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 그 이름이 같은 경우 스프링은 오류를 발생.

→ `ConflictingBeanDefinitionException` 발생

### 수동 빈 등록 vs 자동 빈 등록

스프링은 수동 빈을 우선시한다. → 수동이 자동을 오버라이딩 한다.

하지만 이 경우 정말 잡기 어려운 버그가 생김 → 최근 스프링 부트는 그냥 오류가 발생해버리게 바꿈.